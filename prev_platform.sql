DECLARE mes_inicial DATE DEFAULT DATE '2025-06-01'; -- Mes desde donde se va a empezar el analisis hacia atras
DECLARE meses_hacia_atras INT64 DEFAULT 4;   -- Cantidad de meses para contar hacia atras incluyendo el mes_inicial

-- Armamos una pequeña base de meses analizar
WITH MESES_ANALISIS AS (
  SELECT month_id
  FROM UNNEST(
    GENERATE_DATE_ARRAY(
      DATE_SUB(mes_inicial, INTERVAL meses_hacia_atras - 1 MONTH),
      mes_inicial,
      INTERVAL 1 MONTH
    )
  ) AS month_id
),
-- Utilizamos el CTE NEW_RET_RECO para clasificar los usuarios en NEW, RETAINED, RECOVERED
NEW_RET_RECO AS (
  SELECT
    *,
    DATE_TRUNC(DS, MONTH) AS TIME_FRAME_ID,
    LAG(DS, 1) OVER (PARTITION BY SIT_SITE_ID, USER_ID ORDER BY START_PLAY_TIMESTAMP ASC) AS DS_ANT,
    CASE 
      WHEN LAG(DS, 1) OVER (PARTITION BY SIT_SITE_ID, USER_ID ORDER BY START_PLAY_TIMESTAMP ASC) IS NULL THEN 'NEW'
      WHEN DATE_DIFF(DS, LAG(DS, 1) OVER (PARTITION BY SIT_SITE_ID, USER_ID ORDER BY START_PLAY_TIMESTAMP ASC), DAY) <= 30 THEN 'RETAINED'
      WHEN DATE_DIFF(DS, LAG(DS, 1) OVER (PARTITION BY SIT_SITE_ID, USER_ID ORDER BY START_PLAY_TIMESTAMP ASC), DAY) > 30 THEN 'RECOVERED'
      ELSE NULL 
    END AS FLAG_N_R
  FROM `meli-bi-data.WHOWNER.BT_MKT_MPLAY_PLAYS`
  WHERE PLAYBACK_TIME_MILLISECONDS / 1000 >= 20
    AND DS <= CURRENT_DATE() - 1
),
-- Seleccionamos un único TIME_FRAME
ATTR_TIME_FRAME_ELEGIDO AS (
  SELECT
    SIT_SITE_ID,
    USER_ID,
    TIME_FRAME_ID,
    FLAG_N_R
  FROM NEW_RET_RECO
  QUALIFY ROW_NUMBER() OVER (PARTITION BY SIT_SITE_ID, USER_ID, TIME_FRAME_ID ORDER BY START_PLAY_TIMESTAMP ASC) = 1
),
-- Realizo el join entre NEW_RET_RECO y ATTR_TIME_FRAME_ELEGIDO para tener menos registros
CRUCE_FLAG AS (
  SELECT
    A.*,
    E.FLAG_N_R AS FLAG_N_R_FINAL
  FROM NEW_RET_RECO AS A
  LEFT JOIN ATTR_TIME_FRAME_ELEGIDO AS E
    ON E.SIT_SITE_ID = A.SIT_SITE_ID
    AND E.USER_ID = A.USER_ID
    AND E.TIME_FRAME_ID = A.TIME_FRAME_ID
),
-- Realizo un cálculo para calcular la cantidad de tiempo reproducido por DEVICE y la cantidad de tiempo casteado
RESUMEN_USER_TF AS (
  SELECT
    SIT_SITE_ID,
    USER_ID,
    TIME_FRAME_ID,
    FLAG_N_R_FINAL,
    SUM(PLAYBACK_TIME_MILLISECONDS / 60000) AS TVM_TOTAL_TIMEFRAME,
    SUM(CASE WHEN UPPER(DEVICE_PLATFORM) LIKE '%TV%' THEN PLAYBACK_TIME_MILLISECONDS / 60000 ELSE 0 END) AS TOTAL_TV,
    SUM(CASE WHEN UPPER(DEVICE_PLATFORM) LIKE '%MOBILE%' THEN PLAYBACK_TIME_MILLISECONDS / 60000 ELSE 0 END) AS TOTAL_MOBILE,
    SUM(CASE WHEN UPPER(DEVICE_PLATFORM) LIKE '%DESK%' THEN PLAYBACK_TIME_MILLISECONDS / 60000 ELSE 0 END) AS TOTAL_DESKTOP,
    SUM(PLAYBACK_TIME_MILLISECONDS_CAST / 60000) AS TOTAL_CAST
  FROM CRUCE_FLAG
  GROUP BY 1, 2, 3, 4
),
-- Traigo unicamente aquellos que hayan consumido en SMART y sean RETAINED
USERS_SMART AS (
  SELECT 
    R.SIT_SITE_ID,
    R.USER_ID,
    R.TIME_FRAME_ID AS MONTH_ID,
    FLAG_N_R_FINAL
  FROM RESUMEN_USER_TF R
  JOIN MESES_ANALISIS M ON R.TIME_FRAME_ID = M.month_id
  WHERE 
    CONCAT(
      CASE WHEN TOTAL_TV > 0 THEN 'SMART' ELSE '' END,
      CASE WHEN TOTAL_MOBILE > 0 THEN 'MOBILE' ELSE '' END,
      CASE WHEN TOTAL_DESKTOP > 0 THEN 'DESKTOP' ELSE '' END,
      CASE WHEN TOTAL_CAST > 0 THEN 'CAST' ELSE '' END
    ) LIKE '%SMART%'
    -- AND FLAG_N_R_FINAL = 'RETAINED'-- Comentado para incluir todos los usuarios que consumieron en SMART, PARA RETAINED BORRAR LOS --  
),
LAST_PLATFORM_BEFORE_RETURN AS (
  SELECT 
    U.USER_ID,
    U.SIT_SITE_ID,
    MAX(R.TIME_FRAME_ID) AS LAST_USED_MONTH,
    MAX_BY(
      CONCAT(
        CASE WHEN R.TOTAL_TV > 0 THEN 'SMART' ELSE '' END,
        CASE WHEN R.TOTAL_MOBILE > 0 THEN 'MOBILE' ELSE '' END,
        CASE WHEN R.TOTAL_DESKTOP > 0 THEN 'DESKTOP' ELSE '' END,
        CASE WHEN R.TOTAL_CAST > 0 THEN 'CAST' ELSE '' END
      ),
      R.TIME_FRAME_ID
    ) AS PLATFORM_PREV
  FROM RESUMEN_USER_TF R
  JOIN USERS_SMART U
    ON R.USER_ID = U.USER_ID
    AND R.SIT_SITE_ID = U.SIT_SITE_ID
    AND R.TIME_FRAME_ID < U.MONTH_ID
  GROUP BY U.USER_ID, U.SIT_SITE_ID
),
-- A partir del CTE anterior traigo el listado de usuarios y verifico que PLATFORM tenian en el mes anterior
PLATFORM_PREV_MONTH AS (
  SELECT 
    U.MONTH_ID,
    L.PLATFORM_PREV,
    U.SIT_SITE_ID
    U.USER_ID,
    U.FLAG_N_R_FINAL
  FROM USERS_SMART U
  LEFT JOIN LAST_PLATFORM_BEFORE_RETURN L
    ON L.USER_ID = U.USER_ID
    AND L.SIT_SITE_ID = U.SIT_SITE_ID
),
-- A partir del CTE anterior traigo el listado de usuarios y verifico que PLATFORM tenian y LIFE_CYCLE en el mes anterior
PLATFORM_PREV_WITH_LIFE_CYCLE_PREV AS (
  SELECT 
    U.MONTH_ID,
    L.PLATFORM_PREV,
    U.USER_ID,
    U.SIT_SITE_ID,
    U.FLAG_N_R_FINAL AS CURRENT_LIFE_CYCLE,
    R.FLAG_N_R_FINAL AS PREV_LIFE_CYCLE
  FROM USERS_SMART U
  LEFT JOIN LAST_PLATFORM_BEFORE_RETURN L
    ON L.USER_ID = U.USER_ID
    AND L.SIT_SITE_ID = U.SIT_SITE_ID
  LEFT JOIN RESUMEN_USER_TF R
    ON R.USER_ID = U.USER_ID
    AND R.SIT_SITE_ID = U.SIT_SITE_ID
    AND R.TIME_FRAME_ID = DATE_SUB(U.MONTH_ID, INTERVAL 1 MONTH)
)
-- Resultado final con clasificación de plataforma anterior y life cycle anterior
SELECT 
  MONTH_ID,
  COALESCE(PLATFORM_PREV, 'NO_ACTIVITY_PREV_MONTH') AS PLATFORM_PREV,
  COALESCE(PREV_LIFE_CYCLE, 'NO_ACTIVITY_PREV_MONTH') AS LIFE_CYCLE_PREV,
  SUM(PLAYBACK_TIME_MILLISECONDS / 60000) AS TVM_TOTAL_TIMEFRAME,
  SUM(PLAYBACK_TIME_MILLISECONDS / 60000) / COUNT(DISTINCT USER_ID) AS ATV,
  CURRENT_LIFE_CYCLE,
  COUNT(DISTINCT USER_ID) AS TOTAL_USERS
FROM PLATFORM_PREV_WITH_LIFE_CYCLE_PREV
LEFT JOIN RESUMEN_USER_TF R
  ON R.USER_ID = USER_ID
  AND R.SIT_SITE_ID = SIT_SITE_ID
  AND R.TIME_FRAME_ID = MONTH_ID
WHERE 
  PLATFORM_PREV IS NOT NULL
GROUP BY 1, 2, 3, 4
ORDER BY 1, TOTAL_USERS DESC;



---------------- ES ESTA LA MEJOR -----------------