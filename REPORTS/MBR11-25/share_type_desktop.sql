WITH NEW_RET_RECO AS
(
    SELECT
        *
    , DATE_TRUNC(DS, MONTH) AS TIME_FRAME_ID
    , LAG(DS, 1) OVER(PARTITION BY SIT_SITE_ID, USER_ID ORDER BY START_PLAY_TIMESTAMP ASC) AS DS_ANT
    , (CASE WHEN (LAG(DS, 1) OVER(PARTITION BY SIT_SITE_ID, USER_ID ORDER BY START_PLAY_TIMESTAMP ASC)) IS NULL THEN 'NEW'
            WHEN DATE_DIFF(DS, (LAG(DS, 1) OVER(PARTITION BY SIT_SITE_ID, USER_ID ORDER BY START_PLAY_TIMESTAMP ASC)), DAY) <= 30 THEN 'RETAINED'
            WHEN DATE_DIFF(DS, (LAG(DS, 1) OVER(PARTITION BY SIT_SITE_ID, USER_ID ORDER BY START_PLAY_TIMESTAMP ASC)), DAY) > 30 THEN 'RECOVERED'
            ELSE NULL END) AS FLAG_N_R
    FROM `meli-bi-data.WHOWNER.BT_MKT_MPLAY_PLAYS`
    WHERE PLAYBACK_TIME_MILLISECONDS/1000 >= 20
    AND DS <= CURRENT_DATE - 1
),
ATTR_TIME_FRAME_ELEGIDO AS (
    SELECT
        SIT_SITE_ID,
        USER_ID,
        TIME_FRAME_ID,
        FLAG_N_R
    FROM NEW_RET_RECO
    QUALIFY ROW_NUMBER() OVER(PARTITION BY SIT_SITE_ID, USER_ID, TIME_FRAME_ID ORDER BY START_PLAY_TIMESTAMP ASC) = 1
),
CRUCE_FLAG AS (
    SELECT
        A.*,
        E.FLAG_N_R AS FLAG_N_R_FINAL
    FROM NEW_RET_RECO AS A
    INNER JOIN ATTR_TIME_FRAME_ELEGIDO AS E ON E.SIT_SITE_ID = A.SIT_SITE_ID AND E.USER_ID = A.USER_ID AND E.TIME_FRAME_ID = A.TIME_FRAME_ID
),
RESUMEN_USER_TF AS (
    -- Esta CTE ya genera una fila única por (SITE, USER, MONTH) y es la base de la lógica
    SELECT
        SIT_SITE_ID,
        USER_ID,
        TIME_FRAME_ID,
        FLAG_N_R_FINAL,
        SUM(PLAYBACK_TIME_MILLISECONDS/60000) AS TVM_TOTAL_TIMEFRAME,
        SUM(CASE WHEN UPPER(DEVICE_PLATFORM) LIKE '%DESK%' THEN PLAYBACK_TIME_MILLISECONDS/60000 ELSE 0 END) AS TOTAL_DESKTOP
    FROM CRUCE_FLAG
    GROUP BY ALL
),
BASE_PLATFORM AS (
    -- Usamos RESUMEN_USER_TF, que ya está desagregada por usuario-mes
    SELECT
        USER_ID,
        SIT_SITE_ID,
        TIME_FRAME_ID AS MONTH_ID,
        FLAG_N_R_FINAL AS CUST_TYPE,
        TVM_TOTAL_TIMEFRAME,
        CASE
            -- Definimos el uso de Desktop como TRUE/FALSE
            WHEN TOTAL_DESKTOP > 0 THEN TRUE
            ELSE FALSE
        END AS USED_DESKTOP_IN_MONTH
    FROM RESUMEN_USER_TF
    WHERE TIME_FRAME_ID >= '2025-01-01'
    -- Se elimina GROUP BY ALL para evitar duplicación, ya que RESUMEN_USER_TF ya agrupa.
),
PLATFORM_MIGRATION_DESKTOP AS (
    SELECT
        A.USER_ID,
        A.SIT_SITE_ID,
        A.MONTH_ID,
        A.CUST_TYPE,
        A.USED_DESKTOP_IN_MONTH,
        -- Traemos el uso de Desktop del mes anterior (B)
        B.USED_DESKTOP_IN_MONTH AS USED_DESKTOP_IN_PREV_MONTH, 
        CASE
            -- 1. Si es un usuario NEW (primer mes en la plataforma), es un 'New Desktop Viewer'
            WHEN A.CUST_TYPE = 'NEW' THEN 'NEW DESKTOP VIEWER'
            -- 2. Si usó Desktop en el mes actual Y en el mes anterior
            WHEN A.USED_DESKTOP_IN_MONTH = TRUE AND B.USED_DESKTOP_IN_MONTH = TRUE THEN 'RETAINED DESKTOP'
            -- 3. Si usó Desktop en el mes actual Y NO usó en el mes anterior (NULL o FALSE)
            WHEN A.USED_DESKTOP_IN_MONTH = TRUE AND (B.USED_DESKTOP_IN_MONTH = FALSE OR B.USED_DESKTOP_IN_MONTH IS NULL) THEN 'MIGRATED TO DESKTOP'
            -- 4. Otros casos (usuarios que no usaron Desktop este mes)
            ELSE 'DID NOT USE DESKTOP'
        END AS DESKTOP_MIGRATION_FLOW
    FROM BASE_PLATFORM A
    LEFT JOIN BASE_PLATFORM B
        ON A.USER_ID = B.USER_ID
        AND A.SIT_SITE_ID = B.SIT_SITE_ID
        AND B.MONTH_ID = DATE_SUB(A.MONTH_ID, INTERVAL 1 MONTH)
),
FINAL_DESKTOP_SUMMARY AS (
    SELECT
        MONTH_ID,
        SIT_SITE_ID,
        DESKTOP_MIGRATION_FLOW,
        COUNT(DISTINCT USER_ID) AS TOTAL_USERS
    FROM PLATFORM_MIGRATION_DESKTOP
    -- Filtramos solo los flujos relevantes de Desktop
    WHERE DESKTOP_MIGRATION_FLOW <> 'DID NOT USE DESKTOP'
    GROUP BY ALL
)
SELECT * FROM FINAL_DESKTOP_SUMMARY
ORDER BY MONTH_ID, SIT_SITE_ID, DESKTOP_MIGRATION_FLOW;